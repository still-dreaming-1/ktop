# ktop
top (type oriented programming) in Kotlin

Types are the foundation of all programming. What you can do with a variable, depends on the type. The key to unlocking the power of OOP languages is to see classes as a way to define your own types. If you are stuck with the types built into the language, this is very limiting. But you are not, you can add your own custom types as classes. If you think about it, that is actually what classes are, custom types. They even allow you to define methods which are the equivalent of declaring which "operations" are valid for your type, and what other types those operations can be performed in conjunction with.

Language designers are still not thinking in terms of types and the full benefits we can get by carefully thinking them through, and using them to lock down, express, and test our code. Therefore even the most basic types of our languages are designed completely wrong. Fortunately, we can make our own types as classes and use those instead. For example, a string should not be allowed to be empty. A string (the programming concept) is supposed to be a way to group or string (the verb) characters together as a single value. But if no characters are hung on the string, is it really a string of characters (if a tree falls in the woods..)? The answer is no. An empty string is a redundant concept, conceptually it is the same as null. So if strings were designed properly, you could not set them to an empty string directly as a string literal as that would be a compiler error. And if some operation resulted in an empty string in a way the compiler could not catch it, this would result in a runtime exception. Then when you actually need to use an empty string, you just use null instead. The same thing goes for an empty list, the very concept is a contradiction. You can't have an empty list, you can either have nothing, or a list of things. Nothing is not a list, and a list of nothing is nothing.

This is not just conceptual, there are code readability and contract benefits to getting the types right. In dreamy.types, the S class is a properly designed "string" that will throw an exception if you set it to an empty string. The advantage of this is you can tell just by looking at a method whether it can accept an empty string or not, because it will either accept an S or an S?. For example if you have an `myFun(string: S): S` function, you immediately know an empty string is not a valid thing to pass in, and one will never be returned. But if it looked like `myFun(S string): S?`, you know an empty string is not accepted, but one could be returned, as null (remember null and empty string are the same thing, so really it is just null that is returned, and I should stop talking about empty strings because they are mythical beasts that don't really exist).

Locking down the contracts like that via types, is not just about adding readability, it also helps you lean on the compiler to deal with all the edge cases, and prevent bugs. If a type is allowed to be null, the compiler will make you check for null before using it as if it were not null, but if the type is a String, it won't make you check for an empty string first. This illustrates a deeper truth expressed by type driven development. Types are actually the most natural way to express contracts, and in fact types are contracts.

By locking down your code/contracts with really specific types that don't accept invalid input, and throwing exceptions as soon as invalid input is received, you are ensuring exceptions are thrown as soon as a problem surfaces at runtime, with the most to the point message possible, not later down the road with a difficult to decipher message after all kinds of other side effects have occurred.

Like I said before, language designers have gotten the core types completely wrong, not just for strings and lists, but also for numbers. Just as null is a special case, and passing or returning an empty string or list is often an unintentional or unthought through case, when working with integers, a value of 0 or lower is also often a special error case. Yet most languages still don't have a core integer type that must be greater than zero. Programmers write code making sure the value is not zero over and over again because there is no type for this.

Further suspicions about flaws resulting from not designing languages and code in terms of types:

I suspect the whole testing debacle that exists in the field of programming today, is also partially the result of not programming with types. I cannot defend this viewpoint yet, and I will refine and tweak it as I experiment further with the idea. But basically we have a huge problem where all code is buggy, and needs to have a bunch of automated tests just to work out much of the bugs. Writing correct code is so hard, that unless you have 100% code coverage (using the strictest definition of the word "coverage", which most code coverage tools don't even begin to report), you are all but guaranteed to have lots of bugs. I'm not saying 100% coverage would catch all the bugs, but it would catch many more of them. But then there is the opposite problem where achieving 100% coverage is so humanly unnatural, I would consider imposing this requirement on anyone a form of cruel and unusual punishment. There is something fundamentally wrong with the way we express code that is creating this intractable problem, and I don't know exactly what the solution is, but I think TOP is the beginning of the path that can lead to an answer. In order to solve this problem, I think we need to lean on the concept of "environmental design" as explained in the book "Willpower Doesn't Work - Discover the hidden keys to success", by Benjamin Hardy. Basically the environment created by our current languages and coding strategies, essentially forces us to write code that is buggy (needs tests but they are a pain to write). So we need to somehow create the opposite environment, where properly functioning code naturally comes out, as an emergent property of the environment (languages, tools, and techniques) it came from. This environment needs to be designed for the human programmer, meaning it will never come natural to them to have to be bothered with expressing the solution twice (once as code, and again as code that tests the code).
